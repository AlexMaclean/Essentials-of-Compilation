\documentclass[11pt]{book}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{stmaryrd}
\usepackage{xypic}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 'dedication' environment: To add a dedication paragraph at the start of book %
% Source: http://www.tug.org/pipermail/texhax/2010-June/015184.html            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newenvironment{dedication}
{
   \cleardoublepage
   \thispagestyle{empty}
   \vspace*{\stretch{1}}
   \hfill\begin{minipage}[t]{0.66\textwidth}
   \raggedright
}
{
   \end{minipage}
   \vspace*{\stretch{3}}
   \clearpage
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter quote at the start of chapter        %
% Source: http://tex.stackexchange.com/a/53380 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter
\renewcommand{\@chapapp}{}% Not necessary...
\newenvironment{chapquote}[2][2em]
  {\setlength{\@tempdima}{#1}%
   \def\chapquote@author{#2}%
   \parshape 1 \@tempdima \dimexpr\textwidth-2\@tempdima\relax%
   \itshape}
  {\par\normalfont\hfill--\ \chapquote@author\hspace*{\@tempdima}\par\bigskip}
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\itm}[1]{\mathit{#1}}
\newcommand{\Atom}{\itm{atom}}
\newcommand{\Stmt}{\itm{stmt}}
\newcommand{\Exp}{\itm{exp}}
\newcommand{\Ins}{\itm{instr}}
\newcommand{\Prog}{\itm{prog}}
\newcommand{\Arg}{\itm{arg}}
\newcommand{\Int}{\itm{int}}
\newcommand{\Var}{\itm{var}}
\newcommand{\Op}{\itm{op}}
\newcommand{\key}[1]{\mathtt{#1}}
\newcommand{\Meaning}[1]{\llbracket#1\rrbracket}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% First page of book which contains 'stuff' like: %
%  - Book title, subtitle                         %
%  - Book author name                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Book's title and subtitle
\title{\Huge \textbf{Essentials of Compilation} \\ \huge From Scheme to x86 Assembly}
% Author
\author{\textsc{Jeremy G. Siek}
   \thanks{\url{http://homes.soic.indiana.edu/jsiek/}}
   }


\begin{document}

\frontmatter
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Add a dedication paragraph to dedicate your book to someone %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dedication}
This book is dedicated to the programming languages group at Indiana University.
\end{dedication}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Auto-generated table of contents, list of figures and list of tables %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
%\listoffigures
%\listoftables

\mainmatter

%%%%%%%%%%%
% Preface %
%%%%%%%%%%%
\chapter*{Preface}

\cite{Sarkar:2004fk}
\cite{Keep:2012aa}
\cite{Ghuloum:2006bh}

%\section*{Structure of book}
% You might want to add short description about each chapter in this book.

%\section*{About the companion website}
%The website\footnote{\url{https://github.com/amberj/latex-book-template}} for %this file contains:
%\begin{itemize}
%  \item A link to (freely downlodable) latest version of this document.
%  \item Link to download LaTeX source for this document.
%  \item Miscellaneous material (e.g. suggested readings etc).
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Give credit where credit is due. %
% Say thanks!                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

Need to give thanks to 
\begin{itemize}
\item Kent Dybvig
\item Daniel P. Freidman
\item Oscar Waddell
\item Abdulaziz Ghuloum
\item Dipanwita Sarkar
\end{itemize}

%\mbox{}\\
%\noindent Amber Jain \\
%\noindent \url{http://amberj.devio.us/}

%%%%%%%%%%%%%%%%
% NEW CHAPTER! %
%%%%%%%%%%%%%%%%
\chapter{Integers and Variables}

%\begin{chapquote}{Author's name, \textit{Source of this quote}}
%``This is a quote and I don't know who said this.''
%\end{chapquote}



The $S_0$ language includes integers, operations on integers,
(arithmetic and input), and local variable definitions. This language
is rich enough to exhibit several compilation techniques but simple
enough so that we can implement a compiler for it in two weeks of hard
work.  To give the reader a feeling for the scale of this first
compiler, the instructor solution for the $S_0$ compiler consists of 6
recursive functions and a few small helper functions that together
span 256 lines of code.

The syntax of the $S_0$ language is defined by the following grammar.
\[
\begin{array}{lcl}
  \Op  &::=& \key{+} \mid \key{-} \mid \key{*} \mid \key{read} \\
  \Exp &::=& \Int \mid (\Op \; \Exp^{+}) \mid \Var \mid (\key{let}\, ([\Var \; \Exp])\, \Exp)
\end{array}
\]
The result of evaluating an expression is a value.  For $S_0$,
integers are the only kind of values. To make it straightforward to
map these integers onto x86 assembly, we restrict the integers to just
those representable with 64-bits, the range $-2^{63}$ to $2^{63}$.

The following are a some example expressions in $S_0$ and their value.
\begin{align}
(+ \; 2 \; 3)  &\Longrightarrow 5 \label{p0} \\
(+ \; 2 \; (- (- 3)))  &\Longrightarrow 5 \\
(\key{let}\,([x \; 3])\, (+ \; 2 \; x)) & \Longrightarrow 5 \\
(\key{let}\,([x \; 3])\, (+ \; (\key{let}\,([x\;2])\, x) \; x)) & \Longrightarrow 5  \\
(+ \; (\key{read}) \; 3)  &\Longrightarrow 5 
  & (\text{given input } 2) \\
(+ \; (\key{read}) \; (-\; (\key{read}))) 
& \Longrightarrow 1 \text{ or } -1
& (\text{given input } 3 \; 2) \label{p1}
\end{align}

As we can see, the observable behavior of an $S_0$ program is a
relation between the sequence of inputs and the result value.  The
behavior of the first program \eqref{p0} is to relate any sequence of
input values to the result $5$. 
\[
  \Meaning{(+ \; 2 \; 3)} = \{ (s,5) \mid s \in \mathbb{Z}^{*} \} 
\]
To explain this notation, we write $\Meaning{\exp}$ for the observable
behavior of an expression.  Why do we not instead say that \eqref{p0}
relates the empty sequence $\epsilon$ of inputs to $5$? (As in
$\{(\epsilon,5)\}$.) It is because this program results in $5$
regardless of what input it receives; it ignores the input.

The observable behavior of program \eqref{p1} is somewhat subtle
because Scheme does not specify an evaluation order for arguments of
an operator such as $+$. Thus, the observable behavior for \eqref{p1}
includes two different possible results.  In general, if $n_1$ and
$n_2$ are the first two integers in the input sequence, then
\eqref{p1} can result in either $n_1 + -n_2$ or $n_2 + -n_1$.
\begin{align*}
\Meaning{(+ \; (\key{read}) \; (-\; (\key{read})))} &= B_1 \cup B_2 \\
 \text{where } & B_1 = \{ (n_1\cdot n_2\cdot s, n_1 + -n_2) \mid s \in \mathbb{Z}^{*} \}\\
 \text{and }  & B_2 = \{ (n_1\cdot n_2\cdot s, n_2 + -n_1) \mid s \in \mathbb{Z}^{*} \}
\end{align*}
We include the \texttt{read} operation in $S_0$ to demonstrate that
order of evaluation sometimes makes a difference and also to prevent
the use of an interpreter to trivially implement the compiler for $S_0$.

The goal for this chapter is to implement a compiler that translates
any program $p \in S_0$ into a x86-64 assembly program $p'$ such that
the assembly program exhibits the same behavior on Intel hardward as
the $S_0$ program running in a Scheme implementation.
\[
\xymatrix{
p \in S_0  \ar[rr]^{\text{compile}} \ar[drr]_{\text{run in Scheme}\quad}   &&  p' \in \text{x86-64} \ar[d]^{\quad\text{run on Intel HW}}\\
& & n \in \mathbb{Z}   
}
\]

In the next section we introduce enough of the x86-64 assembly
language to compile $S_0$.



\section{x86-64 Assembly}

\[
\begin{array}{lcl}
\itm{register} &::=& \key{rax} \mid \key{rbx} \mid \key{rcx}
              \mid \key{rdx} \mid \key{rsi} \mid \key{rdi} \mid \\
              && \key{r8} \mid \key{r9} \mid \key{r10}
              \mid \key{r11} \mid \key{r12} \mid \key{r13}
              \mid \key{r14} \mid \key{r15} \\
\Arg &::=&  \Int \mid \itm{register} \mid \Int(\itm{register})\\ 
\Ins &::=& \key{addq} \; \Arg \; \Arg \mid 
      \key{subq} \; \Arg \; \Arg \mid 
      \key{imulq} \; \Arg \; \Arg \mid 
      \key{negq} \; \Arg \mid \\
  && \key{movq} \; \Arg \; \Arg \mid 
      \key{callq} \; \mathit{label} \\
\Prog &::= & \Ins^{*}
\end{array}
\]

\section{An intermediate C-like language}

\[
\begin{array}{lcl}
\Atom &::=& \Int \mid \Var \\
\Exp &::=& \Atom \mid (\Op \; \Atom^{*})\\
\Stmt &::=& (\key{assign} \; \Var \; \Exp) \mid (\key{return}\; \Exp)
\end{array}
\]


\bibliographystyle{plainnat}
\bibliography{all}

\end{document}
