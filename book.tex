\documentclass[11pt]{book}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{stmaryrd}
\usepackage{xypic}

\lstset{%
basicstyle=\ttfamily%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 'dedication' environment: To add a dedication paragraph at the start of book %
% Source: http://www.tug.org/pipermail/texhax/2010-June/015184.html            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newenvironment{dedication}
{
   \cleardoublepage
   \thispagestyle{empty}
   \vspace*{\stretch{1}}
   \hfill\begin{minipage}[t]{0.66\textwidth}
   \raggedright
}
{
   \end{minipage}
   \vspace*{\stretch{3}}
   \clearpage
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter quote at the start of chapter        %
% Source: http://tex.stackexchange.com/a/53380 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter
\renewcommand{\@chapapp}{}% Not necessary...
\newenvironment{chapquote}[2][2em]
  {\setlength{\@tempdima}{#1}%
   \def\chapquote@author{#2}%
   \parshape 1 \@tempdima \dimexpr\textwidth-2\@tempdima\relax%
   \itshape}
  {\par\normalfont\hfill--\ \chapquote@author\hspace*{\@tempdima}\par\bigskip}
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\itm}[1]{\mathit{#1}}
\newcommand{\Atom}{\itm{atom}}
\newcommand{\Stmt}{\itm{stmt}}
\newcommand{\Exp}{\itm{exp}}
\newcommand{\Ins}{\itm{instr}}
\newcommand{\Prog}{\itm{prog}}
\newcommand{\Arg}{\itm{arg}}
\newcommand{\Int}{\itm{int}}
\newcommand{\Var}{\itm{var}}
\newcommand{\Op}{\itm{op}}
\newcommand{\key}[1]{\mathtt{#1}}
\newcommand{\Meaning}[1]{\llbracket#1\rrbracket}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% First page of book which contains 'stuff' like: %
%  - Book title, subtitle                         %
%  - Book author name                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Book's title and subtitle
\title{\Huge \textbf{Essentials of Compilation} \\ \huge From Scheme to x86 Assembly}
% Author
\author{\textsc{Jeremy G. Siek}
   \thanks{\url{http://homes.soic.indiana.edu/jsiek/}}
   }


\begin{document}

\frontmatter
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Add a dedication paragraph to dedicate your book to someone %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dedication}
This book is dedicated to the programming languages group at Indiana University.
\end{dedication}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Auto-generated table of contents, list of figures and list of tables %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
%\listoffigures
%\listoftables

\mainmatter

%%%%%%%%%%%
% Preface %
%%%%%%%%%%%
\chapter*{Preface}

\cite{Sarkar:2004fk}
\cite{Keep:2012aa}
\cite{Ghuloum:2006bh}

%\section*{Structure of book}
% You might want to add short description about each chapter in this book.

%\section*{About the companion website}
%The website\footnote{\url{https://github.com/amberj/latex-book-template}} for %this file contains:
%\begin{itemize}
%  \item A link to (freely downlodable) latest version of this document.
%  \item Link to download LaTeX source for this document.
%  \item Miscellaneous material (e.g. suggested readings etc).
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Give credit where credit is due. %
% Say thanks!                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

Need to give thanks to 
\begin{itemize}
\item Kent Dybvig
\item Daniel P. Freidman
\item Oscar Waddell
\item Abdulaziz Ghuloum
\item Dipanwita Sarkar
\end{itemize}

%\mbox{}\\
%\noindent Amber Jain \\
%\noindent \url{http://amberj.devio.us/}

%%%%%%%%%%%%%%%%
% NEW CHAPTER! %
%%%%%%%%%%%%%%%%
\chapter{Integers and Variables}

%\begin{chapquote}{Author's name, \textit{Source of this quote}}
%``This is a quote and I don't know who said this.''
%\end{chapquote}



The $S_0$ language includes integers, operations on integers,
(arithmetic and input), and local variable definitions. This language
is rich enough to exhibit several compilation techniques but simple
enough so that we can implement a compiler for it in two weeks of hard
work.  To give the reader a feeling for the scale of this first
compiler, the instructor solution for the $S_0$ compiler consists of 6
recursive functions and a few small helper functions that together
span 256 lines of code.

\begin{figure}[tbp]
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
  \Op  &::=& \key{+} \mid \key{-} \mid \key{*} \mid \key{read} \\
  \Exp &::=& \Int \mid (\Op \; \Exp^{+}) \mid \Var \mid (\key{let}\, ([\Var \; \Exp])\, \Exp)
\end{array}
\]
\end{minipage}
}
\caption{The syntax of the $S_0$ language.}
\label{fig:s0-syntax}
\end{figure}

The syntax of the $S_0$ language is defined by the grammar in
Figure~\ref{fig:s0-syntax}. The result of evaluating an expression is
a value.  For $S_0$, integers are the only kind of values. To make it
straightforward to map these integers onto x86-64
assembly~\citep{Matz:2013aa}, we restrict the integers to just those
representable with 64-bits, the range $-2^{63}$ to $2^{63}$.

The following are a some example expressions in $S_0$ and their value.
\begin{align}
(+ \; 10 \; 32)  &\Longrightarrow 42 \label{p0} \\
(+ \; 10 \; (- \;(-\; 32)))  &\Longrightarrow 42 \\
(\key{let}\,([x \; 32])\, (+ \; 10 \; x)) & \Longrightarrow 42 \\
(\key{let}\,([x \; 32])\, (+ \; (\key{let}\,([x\;10])\, x) \; x)) & \Longrightarrow 42  \label{p-shadow}\\
(+ \; (\key{read}) \; 32)  &\Longrightarrow 42
  & (\text{given input } 10) \\
(+ \; (\key{read}) \; (-\; (\key{read}))) 
& \Longrightarrow 1 \text{ or } -1
& (\text{given input } 3 \; 2)  \label{p2}
\end{align}
The \texttt{let} construct stores a value in a variable which can then
be used within the body of the \texttt{let}. When there are multiple
\texttt{let}'s for the same variable, the closest enclosing
\texttt{let} is used, as in program \eqref{p-shadow}.

The behavior of program \eqref{p2} is somewhat subtle because Scheme
does not specify an evaluation order for arguments of an operator such
as $+$. If $n_1$ and $n_2$ are the first two integers in the input
sequence, then program \eqref{p2} can result in either $n_1 + -n_2$ or
$n_2 + -n_1$.  We include the \texttt{read} operation in $S_0$ to
demonstrate that order of evaluation can make a difference.

The goal for this chapter is to implement a compiler that translates
any program $p \in S_0$ into a x86-64 assembly program $p'$ such that
the assembly program exhibits the same behavior on Intel hardward as
the $S_0$ program running in a Scheme implementation.
\[
\xymatrix{
p \in S_0  \ar[rr]^{\text{compile}} \ar[drr]_{\text{run in Scheme}\quad}   &&  p' \in \text{x86-64} \ar[d]^{\quad\text{run on an x86 machine}}\\
& & n \in \mathbb{Z}   
}
\]
In the next section we introduce enough of the x86-64 assembly
language to compile $S_0$.

\section{x86-64 Assembly}

An x86-64 program is a sequence of instructions. The instructions
manipulate a fixed number of variables called \emph{registers} and can
load and store values into \emph{memory}. Memory is a mapping of
64-bit addresses to 64-bit values. The syntax $n(r)$ is used to read
the address $a$ stored in register $r$ and then offset it by $n$,
producing the address $a + n$. The arithmetic instructions, such as
$\key{addq}\,s\,d$, read from the source $s$ and destination argument
$d$, apply the arithmetic operation, then stores the result in the
destination $d$. In this case, computing $d \gets d + s$.  The move
instruction, $\key{movq}\,s\,d$ reads from $s$ and stores the result
in $d$. The $\key{callq}\,\mathit{label}$ instruction executes the
function specified by the label, which we shall use to implement
\texttt{read}. Figure~\ref{fig:x86-a} defines the syntax for this
subset of the x86-64 assembly language.

\begin{figure}[tbp]
\fbox{
\begin{minipage}{0.96\textwidth}
\[
\begin{array}{lcl}
\itm{register} &::=& \key{rax} \mid \key{rbx} \mid \key{rcx}
              \mid \key{rdx} \mid \key{rsi} \mid \key{rdi} \mid \\
              && \key{r8} \mid \key{r9} \mid \key{r10}
              \mid \key{r11} \mid \key{r12} \mid \key{r13}
              \mid \key{r14} \mid \key{r15} \\
\Arg &::=&  \Int \mid \key{\%}\itm{register} \mid \Int(\key{\%}\itm{register}) \\ 
\Ins &::=& \key{addq} \; \Arg \; \Arg \mid 
      \key{subq} \; \Arg \; \Arg \mid 
      \key{imulq} \; \Arg \; \Arg \mid 
      \key{negq} \; \Arg \mid \\
  && \key{movq} \; \Arg \; \Arg \mid 
      \key{callq} \; \mathit{label} \\
\Prog &::= & \Ins^{*}
\end{array}
\]
\end{minipage}
}
\caption{A subset of the x86-64 assembly language.}
\label{fig:x86-a}
\end{figure}

\begin{figure}[tbp]
\begin{lstlisting}
	.globl _main
_main:
	movq	$10, %rax
	addq	$32, %rax
	retq
\end{lstlisting}
\caption{A simple x86-64 program equivalent to $(+ \; 10 \; 32)$.}
\label{fig:p0-x86}
\end{figure}

\section{An intermediate C-like language}

\[
\begin{array}{lcl}
\Atom &::=& \Int \mid \Var \\
\Exp &::=& \Atom \mid (\Op \; \Atom^{*})\\
\Stmt &::=& (\key{assign} \; \Var \; \Exp) \mid (\key{return}\; \Exp)
\end{array}
\]


\bibliographystyle{plainnat}
\bibliography{all}

\end{document}
